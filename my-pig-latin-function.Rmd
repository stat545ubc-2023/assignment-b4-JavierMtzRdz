---
title: "Indexing function"
author: Javier Mtz.-Rdz.
output: github_document
---

# Setup

For this assignment, we will need to load the following packages.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(rlang)
library(gapminder)
library(testthat)
```

# Exercise 1-2: Make and Document your Function

In this section, I developed a function to create an index within a tidy dataset.

```{r}
#' Convert words to custom Pig Latin
#'
#' This function takes a word and converts it to a custom version of Pig Latin.
#'
#' @param word A character vector of words to be converted.
#' @param rearrange A logical value indicating whether to apply the rearrangement component (default is TRUE).
#' @param addition_rule A character string specifying the addition rule to be applied (default is "way").
#'
#' @return A character vector of words converted to Pig Latin.
#'
#' @examples
#' pig_latin_converter(c("hello", "world"))
#'
#' @export
#'
#' @seealso [Pig Latin on Wikipedia](https://en.wikipedia.org/wiki/Pig_Latin)
pig_latin_converter <- function(word, rearrange = TRUE, addition_rule = "ay") {
  if (!is.character(word)) {
    stop("Input 'word' must be a character vector.")
  }
  
  # Function to rearrange the letters
  rearrange_letters <- function(w) {
    if (grepl("^[aeiou]", w)) {
      # For words beginning with vowel sounds
      w <- substring(w, regexpr("[aeiou]", w))
    } else {
      # For words that begin with consonant sounds
      consonant_cluster <- regmatches(w, regexec("^[^aeiou]+", w))
      if (length(consonant_cluster) > 0) {
        w <- paste0(substring(w, regexpr("[^aeiou]+", w) + nchar(consonant_cluster)),
                    substr(consonant_cluster, 1, nchar(consonant_cluster)))
      } else {
        w <- w
      }
    }
    return(w)
  }
  
  # Apply rearrangement and addition rule
  pig_latin_word <- function(w) {
    if (rearrange) {
      w <- rearrange_letters(w)
    }
    return(paste0(w, addition_rule))
  }
  
  # Apply the function to each word in the vector
  result <- sapply(word, pig_latin_word)
  
  return(result)
}

# Test cases
test_that("pig_latin_converter works correctly", {
  words <- c("hello", "world", "apple", "banana", "globe", "shiny")
  converted_words <- pig_latin_converter(words)
  expect_equal(converted_words, c("ellohay", "orldway", "appleay", "ananabay", "obeglay", "inyshay"))
  
  # Test with custom rearrangement rule
  converted_words_custom <- pig_latin_converter(words, rearrange = FALSE)
  expect_equal(converted_words_custom, c("elloway", "orldway", "appleway", "ananabay", "obeglay", "inyshay"))
  
  # Test with a different addition rule
  converted_words_custom_rule <- pig_latin_converter(words, addition_rule = "ixnay")
  expect_equal(converted_words_custom_rule, c("elloixnay", "orldixnay", "appleixnay", "ananabayixnay", "obeglayixnay", "inyshayixnay"))
})

  

```

# Exercise 3: Include examples

## Example 1:
In this example, I generated a time series and established an index using the `values` column. The base observation is set at `2023-01-01`. Then, I created a plot to compare the original column and the indexed one.

```{r}
# Toy dataset
set.seed(545)

df <- tibble(date = seq(as.Date("2023-01-01"), 
                        as.Date("2025-12-01"),
                        "month"),
             values = runif(12*3, 50, 150)*
               (2 + cumsum(runif(12*3, 0, 0.15))))

# Index generation 

d2 <- df %>% 
  indexing(values,
           date == as.Date("2023-01-01"))

# Comparing original variable vs. indexed variable.

d2 %>% 
  ggplot(aes(x = date)) +
  geom_hline(yintercept = 100,
             linetype = "dashed") +
  geom_line(aes(y = values,
                color = "values")) +
  geom_line(aes(y = index,
                color = "index")) +
  theme_minimal()

```


## Example 2:

Using the toy dataset from earlier, this code chunk generates an indexed variable containing the average values of multiple observations. Specifically, it calculates an average for the year 2023. This returns a warning to avoid cases where it was not the intention.

```{r}

d2 <- df %>% 
  indexing(values,
           year(date) == 2023)

# Comparing original variable vs. indexed variable.

d2 %>% 
  ggplot(aes(x = date)) +
  geom_hline(yintercept = 100,
             linetype = "dashed") +
  geom_line(aes(y = values,
                color = "values")) +
  geom_line(aes(y = index,
                color = "index")) +
  theme_minimal()

```

## Example 3:
In this section, I indexed the GDP per capita for Oceania countries taking the year 1952 as the base. Afterwards, I examined the progression over time.

```{r}

idx_gap <- gapminder %>% 
  filter(continent == "Oceania") %>% 
  group_by(country) %>% 
  indexing(gdpPercap,
            year == 1952) 

idx_gap %>% 
    ggplot(aes(x = year, 
             y = index,
             color = country)) +
  geom_line() +
  theme_minimal()

```


# Exercise 4: Test the Function

In this section, I tested the `indexing()` function using the toy dataset.

```{r}


test_that("Testing indexing() function", {
  # This test verifies that the returned data frame contains the right information.
  indexing(df,
           values,
           date == as.Date("2023-01-01")) %>% 
    expect_s3_class("data.frame") %>% 
    expect_length(3) %>% 
    pull(index) %>% 
    last() %>% 
    round() %>% 
    expect_equal(101)
  # This test evaluates the error when a non numeric variable is provided
  expect_error(indexing(df,
                        date,
                        date == as.Date("2023-01-01")), 
               "'date' is not a numeric variable.")
  # This test evaluates the error when reference is not found
  expect_error(indexing(df,
                        values,
                        date == as.Date("2021-01-01")), 
               "Reference not found.")
  # This test evaluates the warning when More than one row is being used as a reference period.
  expect_warning(indexing(df,
                        values,
                        year(date) == 2023), 
               "More than one row is being used as a reference.")
  
})


```
